package audio

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"reflect"

	"accidentallycoded.com/fredboard/v3/internal/telemetry/logging"
)

const (
	connection_Unbounded = -1
	connectionType_In    = "in"
	connectionType_Out   = "out"
)

type InvalidConnectionConfigErr error

func newInvalidConnectionConfigErr(node Node, connectionType string, nMin, nMax, nActual int) InvalidConnectionConfigErr {
	sMin := fmt.Sprintf("%d", nMin)
	if nMin == connection_Unbounded {
		sMin = "UNBOUNDED"
	}

	sMax := fmt.Sprintf("%d", nMax)
	if nMax == connection_Unbounded {
		sMax = "UNBOUNDED"
	}

	return fmt.Errorf("invalid audio graph connection configuration. %s requires min=%s, max=%s \"%s\" connections, but got actual=%d", reflect.TypeOf(node).String(), sMin, sMax, connectionType, nActual)
}

// a unit that processess all input channels are writes to all output channels.
// once Start()ed, the node should not stop processing under any condition unless Stop() is called.
type Node interface {
	// process inputs and writing them to outputs
	// this function should block until all work is complete
	Tick(ins []io.Reader, outs []io.Writer)

	// gets the error generated by the last tick, if any
	Err() error
}

type Connection struct {
	bytes.Buffer

	from Node
	to   Node
}

type Graph struct {
	compositeNode *CompositeNode
}

func (graph *Graph) Tick() {
	graph.compositeNode.Tick([]io.Reader{}, []io.Writer{})
}

func (graph *Graph) AddNode(n Node) {
	graph.compositeNode.AddNode(n)
}

func (graph *Graph) RemoveNode(n Node) {
	graph.compositeNode.RemoveNode(n)
}

func (graph *Graph) CreateConnection(to, from Node) {
	graph.compositeNode.CreateConnection(to, from)
}

func (graph *Graph) RemoveConnection(to, from Node) {
	graph.compositeNode.RemoveConnection(to, from)
}

func NewGraph(logger *logging.Logger) *Graph {
	return &Graph{NewCompositeNode(logger)}
}

// convert little endian bytes to signed 16bit values
func BytesToS16LE(bytes []byte) (s16le []int16) {
	// TODO: handle len(bytes) not divisible by 2. if its not divisible by 2, the last byte will be dropped
	s16le = make([]int16, len(bytes)/2)

	for i := 0; i < len(bytes)/2; i = i + 1 {
		s16le[i] = int16(binary.LittleEndian.Uint16(bytes[i*2 : (i+1)*2]))
	}

	return s16le
}

// convert signed 16bit values to bytes represented in little endian
func S16LEToBytes(s16le []int16) (bytes []byte) {
	bytes = make([]byte, 0, len(s16le)*2)

	for _, v := range s16le {
		bytes = binary.LittleEndian.AppendUint16(bytes, uint16(v))
	}

	return bytes
}
